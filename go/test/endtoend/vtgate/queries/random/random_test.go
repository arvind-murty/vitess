/*
Copyright 2023 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package random

import (
	"fmt"
	"math/rand"
	"testing"
	"time"

	"vitess.io/vitess/go/vt/log"

	"vitess.io/vitess/go/vt/sqlparser"

	"github.com/stretchr/testify/require"

	"vitess.io/vitess/go/test/endtoend/cluster"
	"vitess.io/vitess/go/test/endtoend/utils"
)

// this test uses the AST defined in the sqlparser package to randomly generate queries

type tableT = sqlparser.TableT
type column = sqlparser.Col

// if true then known failing query types are still generated by randomQuery()
const TestFailingQueries = true

func start(t *testing.T) (utils.MySQLCompare, func()) {
	mcmp, err := utils.NewMySQLCompare(t, vtParams, mysqlParams)
	require.NoError(t, err)

	deleteAll := func() {
		_, _ = utils.ExecAllowError(t, mcmp.VtConn, "set workload = oltp")

		tables := []string{"dept", "emp"}
		for _, table := range tables {
			_, _ = mcmp.ExecAndIgnore("delete from " + table)
		}
	}

	deleteAll()

	// disable only_full_group_by
	// mcmp.Exec("set sql_mode=''")

	// insert data
	mcmp.Exec("INSERT INTO emp(empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES (7369,'SMITH','CLERK',7902,'1980-12-17',800,NULL,20), (7499,'ALLEN','SALESMAN',7698,'1981-02-20',1600,300,30), (7521,'WARD','SALESMAN',7698,'1981-02-22',1250,500,30), (7566,'JONES','MANAGER',7839,'1981-04-02',2975,NULL,20), (7654,'MARTIN','SALESMAN',7698,'1981-09-28',1250,1400,30), (7698,'BLAKE','MANAGER',7839,'1981-05-01',2850,NULL,30), (7782,'CLARK','MANAGER',7839,'1981-06-09',2450,NULL,10), (7788,'SCOTT','ANALYST',7566,'1982-12-09',3000,NULL,20), (7839,'KING','PRESIDENT',NULL,'1981-11-17',5000,NULL,10), (7844,'TURNER','SALESMAN',7698,'1981-09-08',1500,0,30), (7876,'ADAMS','CLERK',7788,'1983-01-12',1100,NULL,20), (7900,'JAMES','CLERK',7698,'1981-12-03',950,NULL,30), (7902,'FORD','ANALYST',7566,'1981-12-03',3000,NULL,20), (7934,'MILLER','CLERK',7782,'1982-01-23',1300,NULL,10)")
	mcmp.Exec("INSERT INTO dept(deptno, dname, loc) VALUES ('10','ACCOUNTING','NEW YORK'), ('20','RESEARCH','DALLAS'), ('30','SALES','CHICAGO'), ('40','OPERATIONS','BOSTON')")

	return mcmp, func() {
		deleteAll()
		mcmp.Close()
		cluster.PanicHandler(t)
	}
}

func helperTest(t *testing.T, query string) {
	t.Helper()
	t.Run(query, func(t *testing.T) {
		mcmp, closer := start(t)
		defer closer()

		result, err := mcmp.ExecAllowAndCompareError(query)
		fmt.Println(result)
		fmt.Println(err)
	})
}

func TestMustFix(t *testing.T) {
	require.NoError(t, utils.WaitForAuthoritative(t, keyspaceName, "emp", clusterInstance.VtgateProcess.ReadVSchema))
	require.NoError(t, utils.WaitForAuthoritative(t, keyspaceName, "dept", clusterInstance.VtgateProcess.ReadVSchema))

	// mismatched results
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ distinct count(*) as caggr1 from dept as tbl0, emp as tbl1 group by tbl1.sal having max(tbl1.comm) != true")

	// mismatched results
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ distinct sum(tbl1.loc) as caggr0 from dept as tbl0, dept as tbl1 group by tbl1.deptno having max(tbl1.dname) <= 1")

	// mismatched results
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ distinct max(tbl0.dname) as caggr0, 'cattle' as crandom0 from dept as tbl0, emp as tbl1 where tbl0.deptno != tbl1.sal group by tbl1.comm")

	// mismatched results
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ count(*) as caggr0, 1 as crandom0 from dept as tbl0, emp as tbl1 where 'octopus'")

	// mismatched results
	// previously failing, then succeeding query, now failing again
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ count(tbl0.deptno) from dept as tbl0, emp as tbl1 group by tbl1.job order by tbl1.job limit 3")

	// mismatched results (group by + right join)
	// left instead of right works
	// swapping tables and predicates and changing to left fails
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ max(tbl0.deptno) from dept as tbl0 right join emp as tbl1 on tbl0.deptno = tbl1.empno and tbl0.deptno = tbl1.deptno group by tbl0.deptno")

	// mismatched results (count + right join)
	// left instead of right works
	// swapping tables and predicates and changing to left fails
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ count(tbl1.comm) from emp as tbl1 right join emp as tbl2 on tbl1.mgr = tbl2.sal")
}

func TestKnownFailures(t *testing.T) {
	require.NoError(t, utils.WaitForAuthoritative(t, keyspaceName, "emp", clusterInstance.VtgateProcess.ReadVSchema))
	require.NoError(t, utils.WaitForAuthoritative(t, keyspaceName, "dept", clusterInstance.VtgateProcess.ReadVSchema))

	// logs more stuff
	//clusterInstance.EnableGeneralLog()

	// [BUG] unknown plan type for DISTINCT *planbuilder.filter
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ distinct sum(tbl1.loc) as caggr0 from dept as tbl0, dept as tbl1 group by tbl1.deptno having count(*) <=> tbl1.deptno")

	// vitess error: <nil>
	// mysql error: Unknown column 'tbl0.deptno' in 'having clause'
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ count(*) as caggr0 from dept as tbl0 having tbl0.deptno")

	// coercion should not try to coerce this value: DATE("1980-12-17")
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ distinct tbl1.hiredate as cgroup0, count(tbl1.mgr) as caggr0 from emp as tbl1 group by tbl1.hiredate, tbl1.ename")

	// only_full_group_by enabled (vitess sometimes (?) produces the correct result assuming only_full_group_by is disabled)
	// vitess error: nil
	// mysql error: In aggregated query without GROUP BY, expression #1 of SELECT list contains nonaggregated column 'ks_random.tbl0.ENAME'; this is incompatible with sql_mode=only_full_group_by
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ tbl0.ename, min(tbl0.comm) from emp as tbl0 left join emp as tbl1 on tbl0.empno = tbl1.comm and tbl0.empno = tbl1.empno")

	// only_full_group_by enabled
	// vitess error:  nil
	// mysql error: Expression #1 of ORDER BY clause is not in SELECT list, references column 'ks_random.tbl2.DNAME' which is not in SELECT list; this is incompatible with DISTINCT
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ distinct count(*) as caggr0 from dept as tbl2 group by tbl2.dname order by tbl2.dname asc")

	// vttablet: rpc error: code = NotFound desc = Unknown column 'cgroup0' in 'field list' (errno 1054) (sqlstate 42S22) (CallerID: userData1)
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ tbl1.ename as cgroup0, max(tbl0.comm) as caggr0 from emp as tbl0, emp as tbl1 group by cgroup0")

	// vttablet: rpc error: code = InvalidArgument desc = Can't group on 'count(*)' (errno 1056) (sqlstate 42000) (CallerID: userData1)
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ distinct count(*) from dept as tbl0 group by tbl0.deptno")

	// [BUG] push projection does not yet support: *planbuilder.memorySort (errno 1815) (sqlstate HY000)
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ count(*) from dept as tbl1 join (select count(*) from emp as tbl0, dept as tbl1 group by tbl1.loc) as tbl2")

	// EOF (errno 2013) (sqlstate HY000)
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ count(*) from dept as tbl0, (select /*vt+ PLANNER=Gen4 */ count(*) from emp as tbl0, emp as tbl1 limit 18) as tbl1")

	// unsupported
	// unsupported: in scatter query: complex aggregate expression (errno 1235) (sqlstate 42000)
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ (select count(*) from emp as tbl0) from emp as tbl0")

	// unsupported
	// unsupported: using aggregation on top of a *planbuilder.orderedAggregate plan
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ count(*) from (select count(*) from dept as tbl0) as tbl0")

	// unsupported
	// unsupported: using aggregation on top of a *planbuilder.orderedAggregate plan
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ count(*), count(*) from (select count(*) from dept as tbl0) as tbl0, dept as tbl1")

	// unsupported
	// EOF (errno 2013) (sqlstate HY000)
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ count(*), count(*) from (select count(*) from dept as tbl0 group by tbl0.deptno) as tbl0")

	// unsupported
	// unsupported: in scatter query: aggregation function 'avg(tbl0.deptno)'
	helperTest(t, "select /*vt+ PLANNER=Gen4 */ avg(tbl0.deptno) from dept as tbl0")
}

func TestRandom(t *testing.T) {
	mcmp, closer := start(t)
	defer closer()

	require.NoError(t, utils.WaitForAuthoritative(t, keyspaceName, "emp", clusterInstance.VtgateProcess.ReadVSchema))
	require.NoError(t, utils.WaitForAuthoritative(t, keyspaceName, "dept", clusterInstance.VtgateProcess.ReadVSchema))

	// specify the schema (that is defined in schema.sql)
	schemaTables := []tableT{
		{Name: sqlparser.NewTableName("emp")},
		{Name: sqlparser.NewTableName("dept")},
	}
	schemaTables[0].AddColumns([]column{
		{Name: "empno", Typ: "bigint"},
		{Name: "ename", Typ: "varchar"},
		{Name: "job", Typ: "varchar"},
		{Name: "mgr", Typ: "bigint"},
		{Name: "hiredate", Typ: "date"},
		{Name: "sal", Typ: "bigint"},
		{Name: "comm", Typ: "bigint"},
		{Name: "deptno", Typ: "bigint"},
	}...)
	schemaTables[1].AddColumns([]column{
		{Name: "deptno", Typ: "bigint"},
		{Name: "dname", Typ: "varchar"},
		{Name: "loc", Typ: "varchar"},
	}...)

	endBy := time.Now().Add(10 * time.Second)

	var queryCount int
	for time.Now().Before(endBy) && (!t.Failed() || TestFailingQueries) {
		query := sqlparser.String(randomQuery(schemaTables, 3, 3))
		_, vtErr := mcmp.ExecAllowAndCompareError(query)
		// this assumes all queries are valid mysql queries
		if vtErr != nil {
			fmt.Println(query)
			fmt.Println(vtErr)
			// restart the mysql and vitess connections in case something bad happened
			closer()
			mcmp, closer = start(t)
		}
		queryCount++
	}
	fmt.Printf("Queries successfully executed: %d\n", queryCount)
}

// TODO: bunch of TestFailingQueries checks were deleted by refactor to use AST
func randomQuery(schemaTables []tableT, maxAggrs, maxGroupBy int) *sqlparser.Select {
	sel := &sqlparser.Select{}
	sel.SetComments(sqlparser.Comments{"/*vt+ PLANNER=Gen4 */"})

	// select distinct (fails with group by bigint)
	isDistinct := rand.Intn(2) < 1
	if isDistinct {
		sel.MakeDistinct()
	}

	// create both tables and join at the same time since both occupy the from clause
	tables, isJoin := createTablesAndJoin(schemaTables, sel)

	groupExprs, groupSelectExprs, grouping := createGroupBy(tables, maxGroupBy)
	sel.AddSelectExprs(groupSelectExprs)
	sel.GroupBy = groupExprs
	aggrExprs, aggregates := createAggregations(tables, maxAggrs)
	sel.AddSelectExprs(aggrExprs)

	// can add both aggregate and grouping columns to order by
	isOrdered := rand.Intn(2) < 1
	if isOrdered && (!isDistinct || TestFailingQueries) && (!isJoin || TestFailingQueries) {
		addOrderBy(sel)
	}

	// where
	sel.AddWhere(sqlparser.AndExpressions(createWherePredicates(tables, false)...))

	// random predicate expression
	if rand.Intn(2) < 1 {
		predRandomExpr, _ := getRandomExpr(tables)
		sel.AddWhere(predRandomExpr)
	}

	// having
	sel.AddHaving(sqlparser.AndExpressions(createHavingPredicates(tables)...))
	if rand.Intn(2) < 1 {
		sel.AddHaving(sqlparser.AndExpressions(createWherePredicates(tables, false)...))
	}

	// only add a limit if the grouping columns are ordered
	if rand.Intn(2) < 1 && isOrdered {
		sel.Limit = createLimit()
	}

	var newTable tableT
	// add random expression to select
	isRandomExpr := rand.Intn(2) < 1
	randomExpr, typ := getRandomExpr(tables)
	if isRandomExpr && (!isDistinct || TestFailingQueries) && (!isJoin || TestFailingQueries) {
		sel.SelectExprs = append(sel.SelectExprs, sqlparser.NewAliasedExpr(randomExpr, "crandom0"))
		newTable.AddColumns(column{
			Name: "crandom0",
			Typ:  typ,
		})
	}

	// alias grouping and aggregate columns
	for i := range grouping {
		grouping[i].Name = fmt.Sprintf("cgroup%d", i)
	}
	for i := range aggregates {
		aggregates[i].Name = fmt.Sprintf("cgroup%d", i)
	}

	// add them to newTable
	newTable.AddColumns(grouping...)
	newTable.AddColumns(aggregates...)

	// add new table to schemaTables
	newTable.Name = sqlparser.NewDerivedTable(false, sel)
	schemaTables = append(schemaTables, newTable)

	// derived tables (partially unsupported)
	if rand.Intn(10) < 1 && TestFailingQueries {
		sel = randomQuery(schemaTables, 3, 3)
	}

	return sel
}

func createTablesAndJoin(schemaTables []tableT, sel *sqlparser.Select) ([]tableT, bool) {
	var tables []tableT
	// add at least one of original emp/dept tables for now because derived tables have nil columns
	tables = append(tables, schemaTables[rand.Intn(2)])

	sel.From = append(sel.From, newAliasedTable(tables[0], "tbl0"))
	tables[0].SetName("tbl0")

	numTables := rand.Intn(len(schemaTables))
	for i := 0; i < numTables; i++ {
		tables = append(tables, randomEl(schemaTables))
		sel.From = append(sel.From, newAliasedTable(tables[i+1], fmt.Sprintf("tbl%d", i+1)))
		tables[i+1].SetName(fmt.Sprintf("tbl%d", i+1))
	}

	isJoin := rand.Intn(2) < 1
	if isJoin {
		newTable := randomEl(schemaTables)
		tables = append(tables, newTable)

		// create the join before aliasing
		newJoinTableExpr := createJoin(tables, sel)

		// alias
		tables[numTables+1].SetName(fmt.Sprintf("tbl%d", numTables+1))

		// create the condition after aliasing
		newJoinTableExpr.Condition = sqlparser.NewJoinCondition(sqlparser.AndExpressions(createWherePredicates(tables, true)...), nil)
		sel.From[numTables] = newJoinTableExpr
	}

	return tables, isJoin
}

// creates a left join (without the condition) between the last table in sel and newTable
// tables should have one more table than sel
func createJoin(tables []tableT, sel *sqlparser.Select) *sqlparser.JoinTableExpr {
	n := len(sel.From)
	if len(tables) != n+1 {
		log.Fatalf("sel has %d tables and tables has %d tables", len(sel.From), n)
	}

	return sqlparser.NewJoinTableExpr(sel.From[n-1], sqlparser.LeftJoinType, newAliasedTable(tables[n], fmt.Sprintf("tbl%d", n)), nil)
}

// adds grouping columns to sel.GroupBy and optionally to sel.SelectExprs and sel.OrderBy
// TODO: maybe change to return this stuff instead
func createGroupBy(tables []tableT, maxGB int) (groupBy sqlparser.GroupBy, groupSelectExprs sqlparser.SelectExprs, grouping []column) {
	numGBs := rand.Intn(maxGB)
	for i := 0; i < numGBs; i++ {
		tblIdx := rand.Intn(len(tables))
		col := randomEl(tables[tblIdx].Cols)
		groupBy = append(groupBy, newColumn(col))

		// add to select
		if rand.Intn(2) < 1 {
			groupSelectExprs = append(groupSelectExprs, newAliasedColumn(col, fmt.Sprintf("cgroup%d", i)))
			grouping = append(grouping, col)
		}
	}

	return groupBy, groupSelectExprs, grouping
}

// adds aggregation columns to sel.SelectExprs and optionally to sel.OrderBy
// TODO: maybe change to return this stuff instead
func createAggregations(tables []tableT, maxAggrs int) (aggrExprs sqlparser.SelectExprs, aggregates []column) {
	aggregations := []func(col column) sqlparser.Expr{
		func(_ column) sqlparser.Expr { return &sqlparser.CountStar{} },
		func(col column) sqlparser.Expr { return &sqlparser.Count{Args: sqlparser.Exprs{newColumn(col)}} },
		func(col column) sqlparser.Expr { return &sqlparser.Sum{Arg: newColumn(col)} },
		// func(col column) sqlparser.Expr { return &sqlparser.Avg{Arg: newAggregateExpr(col)} },
		func(col column) sqlparser.Expr { return &sqlparser.Min{Arg: newColumn(col)} },
		func(col column) sqlparser.Expr { return &sqlparser.Max{Arg: newColumn(col)} },
	}

	numAggrs := rand.Intn(maxAggrs) + 1
	for i := 0; i < numAggrs; i++ {
		tblIdx, aggrIdx := rand.Intn(len(tables)), rand.Intn(len(aggregations))
		col := randomEl(tables[tblIdx].Cols)
		newAggregate := aggregations[aggrIdx](col)
		aggrExprs = append(aggrExprs, sqlparser.NewAliasedExpr(newAggregate, fmt.Sprintf("caggr%d", i)))

		if aggrIdx <= 1 /* CountStar and Count */ {
			col.Typ = "bigint"
		} else if _, ok := newAggregate.(*sqlparser.Avg); ok && col.GetColumnName() == "bigint" {
			col.Typ = "decimal"
		}

		col.Name = sqlparser.String(newAggregate)
		aggregates = append(aggregates, col)
	}
	return aggrExprs, aggregates
}

// orders on all non-aggregate SelectExprs and independently at random on all aggregate SelectExprs of sel
func addOrderBy(sel *sqlparser.Select) {
	for _, selExpr := range sel.SelectExprs {
		if aliasedExpr, ok := selExpr.(*sqlparser.AliasedExpr); ok {
			// if the SelectExpr is non-aggregate (the AliasedExpr has Expr of type ColName)
			// then add to the order by
			if colName, ok1 := aliasedExpr.Expr.(*sqlparser.ColName); ok1 {
				sel.AddOrder(sqlparser.NewOrder(colName, getRandomOrderDirection()))
			} else if rand.Intn(2) < 1 {
				sel.AddOrder(sqlparser.NewOrder(aliasedExpr.Expr, getRandomOrderDirection()))
			}
		}
	}
}

// returns the predicates as a sqlparser.Exprs (slice of sqlparser.Expr's)
func createWherePredicates(tables []tableT, isJoin bool) (predicates sqlparser.Exprs) {
	// if creating predicates for a join,
	// then make sure predicates are created for the last two tables (which are being joined)
	incr := 0
	if isJoin && len(tables) > 2 {
		incr += len(tables) - 2
	}

	for idx1 := range tables {
		for idx2 := range tables {
			// fmt.Printf("predicate tables:\n%v\n idx1: %d idx2: %d, incr: %d", tables, idx1, idx2, incr)
			if idx1 >= idx2 || idx1 < incr || idx2 < incr {
				continue
			}
			noOfPredicates := rand.Intn(2)
			if isJoin {
				noOfPredicates++
			}

			for i := 0; noOfPredicates > 0; i++ {
				col1 := randomEl(tables[idx1].Cols)
				col2 := randomEl(tables[idx2].Cols)

				// prevent infinite loops
				if i > 50 {
					predicates = append(predicates, sqlparser.NewComparisonExpr(getRandomComparisonExprOperator(), newColumn(col1), newColumn(col2), nil))
					break
				}

				if col1.Typ != col2.Typ {
					continue
				}

				predicates = append(predicates, sqlparser.NewComparisonExpr(getRandomComparisonExprOperator(), newColumn(col1), newColumn(col2), nil))
				noOfPredicates--
			}
		}
	}

	// make sure the join predicate is never empty
	if len(predicates) == 0 && isJoin {
		predRandomExpr, _ := getRandomExpr(tables)
		predicates = append(predicates, predRandomExpr)
	}

	return predicates
}

func createHavingPredicates(tables []tableT) (havingPredicates sqlparser.Exprs) {
	aggrSelectExprs, _ := createAggregations(tables, 3)
	for i := range aggrSelectExprs {
		if aliasedExpr, ok := aggrSelectExprs[i].(*sqlparser.AliasedExpr); ok {
			predRandomExpr, _ := getRandomExpr(tables)
			havingPredicates = append(havingPredicates, sqlparser.NewComparisonExpr(getRandomComparisonExprOperator(), aliasedExpr.Expr, predRandomExpr, nil))
		}
	}
	return havingPredicates
}

// creates sel.Limit
func createLimit() *sqlparser.Limit {
	limitNum := rand.Intn(10)
	if rand.Intn(2) < 1 {
		offset := rand.Intn(10)
		return sqlparser.NewLimit(offset, limitNum)
	} else {
		return sqlparser.NewLimitWithoutOffset(limitNum)
	}

}

// returns a random expression and its type
func getRandomExpr(tables []tableT) (sqlparser.Expr, string) {
	seed := time.Now().UnixNano()
	g := sqlparser.NewGenerator(seed, 2, tables...)
	return g.Expression()
}

func newAliasedTable(tbl tableT, alias string) *sqlparser.AliasedTableExpr {
	return sqlparser.NewAliasedTableExpr(tbl.Name, alias)
}

func newAliasedColumn(col column, alias string) *sqlparser.AliasedExpr {
	return sqlparser.NewAliasedExpr(newColumn(col), alias)
}

func newColumn(col column) *sqlparser.ColName {
	return sqlparser.NewColNameWithQualifier(col.Name, sqlparser.NewTableName(col.TableName))
}

func getRandomComparisonExprOperator() sqlparser.ComparisonExprOperator {
	// =, <, >, <=, >=, !=, <=>
	return randomEl([]sqlparser.ComparisonExprOperator{0, 1, 2, 3, 4, 5, 6})
}

func getRandomOrderDirection() sqlparser.OrderDirection {
	// asc, desc
	return randomEl([]sqlparser.OrderDirection{0, 1})
}

func randomEl[K any](in []K) K {
	return in[rand.Intn(len(in))]
}
