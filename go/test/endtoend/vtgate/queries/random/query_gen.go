/*
Copyright 2023 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package random

import (
	"fmt"
	"math/rand"
	"time"

	"golang.org/x/exp/slices"

	"vitess.io/vitess/go/slices2"

	"vitess.io/vitess/go/vt/log"
	"vitess.io/vitess/go/vt/sqlparser"
)

// this file contains the structs and functions to generate random queries

// if true then known failing query types are still generated by randomQuery()
const testFailingQueries = false

type (
	column struct {
		name *sqlparser.ColName
		typ  string
	}

	tableT struct {
		// the tableT struct can be used to represent the schema of a table or a derived table
		// in the former case tableExpr will be a sqlparser.TableName, in the latter a sqlparser.DerivedTable
		// in order to create a query with a derived table, its AST form is retrieved from tableExpr
		// once the derived table is aliased, alias is updated
		tableExpr sqlparser.SimpleTableExpr
		alias     string
		cols      []column
	}
)

var _ sqlparser.ExprGenerator = (*tableT)(nil)
var _ sqlparser.ExprGenerator = (*column)(nil)

// getColumnName returns tableName.name
func (c *column) getColumnName() string {
	return sqlparser.String(c.name)
}

func (c *column) Generate(genConfig sqlparser.ExprGeneratorConfig) sqlparser.Expr {
	if c.typ == genConfig.Type {
		return c.name
	}

	return nil
}

func (t *tableT) Generate(genConfig sqlparser.ExprGeneratorConfig) sqlparser.Expr {
	colsCopy := slices.Clone(t.cols)

	for len(colsCopy) > 0 {
		idx := rand.Intn(len(colsCopy))
		randCol := colsCopy[idx]
		if randCol.typ == genConfig.Type {
			return randCol.name
		}

		// delete randCol from colsCopy
		colsCopy[idx] = colsCopy[len(colsCopy)-1]
		colsCopy = colsCopy[:len(colsCopy)-1]
	}

	return nil
}

// getName returns the alias if it is nonempty
// if the alias is nonempty and tableExpr is of type sqlparser.TableName,
// then getName returns Name from tableExpr
// otherwise getName returns an empty string
func (t *tableT) getName() string {
	if t.alias != "" {
		return t.alias
	} else if tName, ok := t.tableExpr.(sqlparser.TableName); ok {
		return sqlparser.String(tName.Name)
	}

	return ""
}

// setAlias sets the alias for t, as well as setting the tableName for all columns in cols
func (t *tableT) setAlias(newName string) {
	t.alias = newName
	for i := range t.cols {
		t.cols[i].name.Qualifier = sqlparser.NewTableName(newName)
	}
}

// addColumns adds columns to t, and automatically assigns each column.tableName
// this makes it unnatural to modify tableName
func (t *tableT) addColumns(col ...column) {
	for i := range col {
		col[i].name.Qualifier = sqlparser.NewTableName(t.getName())
		t.cols = append(t.cols, col[i])
	}
}

func randomQuery(schemaTables []tableT, maxAggrs, maxGroupBy int) *sqlparser.Select {
	sel := &sqlparser.Select{}
	sel.SetComments(sqlparser.Comments{"/*vt+ PLANNER=Gen4 */"})

	// select distinct (fails with group by bigint)
	isDistinct := rand.Intn(2) < 1
	if isDistinct {
		sel.MakeDistinct()
	}

	// create both tables and join at the same time since both occupy the from clause
	tables, isJoin := createTablesAndJoin(schemaTables, sel)

	// canAggregate determines if the query will have
	// aggregate columns, group by, and having
	canAggregate := rand.Intn(4) > 0

	var (
		groupBy          sqlparser.GroupBy
		groupSelectExprs sqlparser.SelectExprs
		grouping         []column
		aggrExprs        sqlparser.SelectExprs
		aggregates       []column
	)
	// TODO: distinct makes vitess think there is grouping on aggregation columns
	if canAggregate {
		if testFailingQueries || !isDistinct {
			// group by
			groupBy, groupSelectExprs, grouping = createGroupBy(tables, maxGroupBy)
			sel.AddSelectExprs(groupSelectExprs)
			sel.GroupBy = groupBy
		}

		// aggregate columns
		aggrExprs, aggregates = createAggregations(tables, maxAggrs)
		sel.AddSelectExprs(aggrExprs)

		// having
		isHaving := rand.Intn(2) < 1
		if isHaving {
			sel.AddHaving(sqlparser.AndExpressions(createHavingPredicates(tables)...))
			if rand.Intn(2) < 1 && testFailingQueries {
				// TODO: having can only contain aggregate or grouping columns in mysql, works fine in vitess
				// TODO: Can fix this by putting only the table with the grouping and aggregates column (newTable)
				sel.AddHaving(sqlparser.AndExpressions(createWherePredicates(tables)...))
			}
		}
		// TODO: use sqlparser.ExprGenerator to generate a random expression with aggregation functions

	}

	// can add both aggregate and grouping columns to order by
	// TODO: order fails with distinct and outer joins
	isOrdered := rand.Intn(2) < 1 && (!isDistinct || testFailingQueries) && (!isJoin || testFailingQueries) && testFailingQueries
	// TODO: order by fails a lot; probably related to the previously passing query
	// TODO: should be fixed soon
	if isOrdered {
		sel.OrderBy = createOrderBy(groupBy, aggrExprs)
	}

	// TODO: random expressions cause a lot of failures
	// where
	sel.AddWhere(sqlparser.AndExpressions(createWherePredicates(tables)...))

	// only add a limit if the grouping columns are ordered
	// TODO: limit fails a lot
	if rand.Intn(2) < 1 && (isOrdered || len(groupBy) == 0) && testFailingQueries {
		sel.Limit = createLimit()
	}

	var (
		newTable tableT
		f        func() sqlparser.Expr
		typ      string
	)
	// add random expression to select
	// TODO: random expressions cause a lot of failures
	isRandomExpr := rand.Intn(2) < 1 && testFailingQueries

	// TODO: selecting a random expression potentially with columns creates
	// TODO: only_full_group_by related errors in Vitess
	if testFailingQueries {
		// TODO: ugly
		f = func() sqlparser.Expr {
			return getRandomExpr(sqlparser.ExprGeneratorConfig{}, slices2.Map(tables, func(t tableT) sqlparser.ExprGenerator {
				return &t
			})...)
		}
	} else {
		f = func() sqlparser.Expr { return getRandomExpr(sqlparser.ExprGeneratorConfig{}) }
	}

	// make sure we have at least one select expression
	for isRandomExpr || len(sel.SelectExprs) == 0 {
		// TODO: if the random expression is an int literal,
		// TODO: and if the query is (potentially) an aggregate query,
		// TODO: then we must group by the random expression,
		// TODO: but we cannot do this for int literals,
		// TODO: so we loop until we get a non-int-literal random expression
		// TODO: this is necessary because grouping by the alias (crandom0) currently fails on vitess
		randomExpr := f()
		literal, ok := randomExpr.(*sqlparser.Literal)
		isIntLiteral := ok && literal.Type == sqlparser.IntVal
		if isIntLiteral && canAggregate {
			continue
		}

		// TODO: select distinct [literal] fails
		sel.Distinct = false

		sel.SelectExprs = append(sel.SelectExprs, sqlparser.NewAliasedExpr(randomExpr, "crandom0"))
		newTable.addColumns(column{
			name: sqlparser.NewColName("crandom0"),
			typ:  typ,
		})

		// make sure to add the random expression to group by and order by for only_full_group_by
		if canAggregate {
			sel.AddGroupBy(randomExpr)
			sel.AddOrder(sqlparser.NewOrder(randomExpr, getRandomOrderDirection()))
		}

		break
	}

	// add them to newTable
	newTable.addColumns(grouping...)
	newTable.addColumns(aggregates...)

	// add new table to schemaTables
	newTable.tableExpr = sqlparser.NewDerivedTable(false, sel)
	schemaTables = append(schemaTables, newTable)

	// derived tables (partially unsupported)
	// TODO: derived tables fails a lot
	if rand.Intn(10) < 1 && testFailingQueries {
		sel = randomQuery(schemaTables, 3, 3)
	}

	return sel
}

func createTablesAndJoin(schemaTables []tableT, sel *sqlparser.Select) ([]tableT, bool) {
	var tables []tableT
	// add at least one of original emp/dept tables for now because derived tables have nil columns
	tables = append(tables, schemaTables[rand.Intn(2)])

	sel.From = append(sel.From, newAliasedTable(tables[0], "tbl0"))
	tables[0].setAlias("tbl0")

	numTables := rand.Intn(len(schemaTables))
	for i := 0; i < numTables; i++ {
		tables = append(tables, randomEl(schemaTables))
		sel.From = append(sel.From, newAliasedTable(tables[i+1], fmt.Sprintf("tbl%d", i+1)))
		tables[i+1].setAlias(fmt.Sprintf("tbl%d", i+1))
	}

	// TODO: outer joins produce mismatched results
	isJoin := rand.Intn(2) < 1 && testFailingQueries
	if isJoin {
		// TODO: do nested joins
		newTable := randomEl(schemaTables)
		newTable.setAlias(fmt.Sprintf("tbl%d", numTables))
		tables = append(tables, newTable)

		createJoin(tables, sel)
	}

	return tables, isJoin
}

// creates a left join (without the condition) between the last table in sel and newTable
// tables should have one more table than sel
func createJoin(tables []tableT, sel *sqlparser.Select) {
	n := len(sel.From)
	if len(tables) != n+1 {
		log.Fatalf("sel has %d tables and tables has %d tables", len(sel.From), n)
	}

	joinPredicate := sqlparser.AndExpressions(createJoinPredicates(tables)...)
	joinCondition := sqlparser.NewJoinCondition(joinPredicate, nil)
	newTable := newAliasedTable(tables[n], fmt.Sprintf("tbl%d", n))
	sel.From[n-1] = sqlparser.NewJoinTableExpr(sel.From[n-1], sqlparser.LeftJoinType, newTable, joinCondition)
}

// returns 1-3 random expressions based on the last two elements of tables
// tables should have at least two elements
func createJoinPredicates(tables []tableT) sqlparser.Exprs {
	if len(tables) < 2 {
		log.Fatalf("tables has %d elements, needs at least 2", len(tables))
	}

	return createPredicates(1, &tables[len(tables)-2], &tables[len(tables)-1])
}

// returns the grouping columns as three types: sqlparser.GroupBy, sqlparser.SelectExprs, []column
func createGroupBy(tables []tableT, maxGB int) (groupBy sqlparser.GroupBy, groupSelectExprs sqlparser.SelectExprs, grouping []column) {
	numGBs := rand.Intn(maxGB)
	for i := 0; i < numGBs; i++ {
		tblIdx := rand.Intn(len(tables))
		col := randomEl(tables[tblIdx].cols)
		// TODO: grouping by a date column sometimes errors
		if col.typ == "date" && !testFailingQueries {
			continue
		}
		groupBy = append(groupBy, col.name)

		// add to select
		if rand.Intn(2) < 1 {
			groupSelectExprs = append(groupSelectExprs, newAliasedColumn(col, fmt.Sprintf("cgroup%d", i)))
			// TODO: alias in a separate function to properly generate the having clause
			col.name = sqlparser.NewColName(fmt.Sprintf("cgroup%d", i))
			grouping = append(grouping, col)
		}
	}

	return
}

// returns the aggregation columns as three types: sqlparser.SelectExprs, []column
func createAggregations(tables []tableT, maxAggrs int) (aggrExprs sqlparser.SelectExprs, aggregates []column) {
	aggregations := []func(col column) sqlparser.Expr{
		func(_ column) sqlparser.Expr { return &sqlparser.CountStar{} },
		func(col column) sqlparser.Expr { return &sqlparser.Count{Args: sqlparser.Exprs{col.name}} },
		func(col column) sqlparser.Expr { return &sqlparser.Sum{Arg: col.name} },
		// func(col column) sqlparser.Expr { return &sqlparser.Avg{Arg: col.name} },
		func(col column) sqlparser.Expr { return &sqlparser.Min{Arg: col.name} },
		func(col column) sqlparser.Expr { return &sqlparser.Max{Arg: col.name} },
	}

	numAggrs := rand.Intn(maxAggrs)
	for i := 0; i < numAggrs; i++ {
		tblIdx, aggrIdx := rand.Intn(len(tables)), rand.Intn(len(aggregations))
		col := randomEl(tables[tblIdx].cols)
		// TODO: aggregating on a date column sometimes errors
		if col.typ == "date" && !testFailingQueries {
			i--
			continue
		}

		newAggregate := aggregations[aggrIdx](col)
		// TODO: collating on strings sometimes errors
		if col.typ == "varchar" && !testFailingQueries {
			switch newAggregate.(type) {
			case *sqlparser.Min, *sqlparser.Max:
				i--
				continue
			}
		}

		// TODO: type of sum() is incorrect (int64 vs decimal) in certain queries
		if _, ok := newAggregate.(*sqlparser.Sum); ok && !testFailingQueries {
			i--
			continue
		}

		aggrExprs = append(aggrExprs, sqlparser.NewAliasedExpr(newAggregate, fmt.Sprintf("caggr%d", i)))

		if aggrIdx <= 1 /* CountStar and Count */ {
			col.typ = "bigint"
		} else if _, ok := newAggregate.(*sqlparser.Avg); ok && col.getColumnName() == "bigint" {
			col.typ = "decimal"
		}

		col.name = sqlparser.NewColName(fmt.Sprintf("caggr%d", i))
		aggregates = append(aggregates, col)
	}
	return
}

// orders on all non-aggregate SelectExprs and independently at random on all aggregate SelectExprs of sel
func createOrderBy(groupBy sqlparser.GroupBy, aggrExprs sqlparser.SelectExprs) (orderBy sqlparser.OrderBy) {
	// always order on grouping columns
	for i := range groupBy {
		orderBy = append(orderBy, sqlparser.NewOrder(groupBy[i], getRandomOrderDirection()))
	}

	// randomly order on aggregation columns
	for i := range aggrExprs {
		if aliasedExpr, ok := aggrExprs[i].(*sqlparser.AliasedExpr); ok && rand.Intn(2) < 1 {
			orderBy = append(orderBy, sqlparser.NewOrder(aliasedExpr.Expr, getRandomOrderDirection()))
		}
	}

	return
}

// returns 0-2 random expressions based on tables
func createWherePredicates(tables []tableT) sqlparser.Exprs {
	return createPredicates(0, slices2.Map(tables, func(t tableT) sqlparser.ExprGenerator { return &t })...)
}

// returns between minPredicates and minPredicates + 2 random expressions using generators
func createPredicates(minPredicates int, generators ...sqlparser.ExprGenerator) (predicates sqlparser.Exprs) {
	numPredicates := rand.Intn(3) + minPredicates
	for i := 0; i < numPredicates; i++ {
		predicates = append(predicates, getRandomExpr(sqlparser.ExprGeneratorConfig{}, generators...))
	}

	return
}

// creates predicates for the having clause comparing a column to a random expression
func createHavingPredicates(tables []tableT) (havingPredicates sqlparser.Exprs) {
	aggrSelectExprs, _ := createAggregations(tables, 2) // createAggregations(generators)
	for i := range aggrSelectExprs {
		if lhs, ok := aggrSelectExprs[i].(*sqlparser.AliasedExpr); ok {
			// TODO: HAVING can only contain aggregate or grouping columns in mysql, works fine in vitess
			// TODO: Can fix this by putting only the table with the grouping and aggregates column (newTable)
			// TODO: but random expressions without the columns also fails
			if testFailingQueries {
				predRandomExpr := getRandomExpr(sqlparser.ExprGeneratorConfig{}, slices2.Map(tables, func(t tableT) sqlparser.ExprGenerator {
					return &t
				})...)
				havingPredicates = append(havingPredicates, sqlparser.NewComparisonExpr(getRandomComparisonExprOperator(), lhs.Expr, predRandomExpr, nil))
			} else if rhs, ok1 := randomEl(aggrSelectExprs).(*sqlparser.AliasedExpr); ok1 {
				havingPredicates = append(havingPredicates, sqlparser.NewComparisonExpr(getRandomComparisonExprOperator(), lhs.Expr, rhs.Expr, nil))
			}
		}
	}
	return
}

// creates sel.Limit
func createLimit() *sqlparser.Limit {
	limitNum := rand.Intn(10)
	if rand.Intn(2) < 1 {
		offset := rand.Intn(10)
		return sqlparser.NewLimit(offset, limitNum)
	}

	return sqlparser.NewLimitWithoutOffset(limitNum)
}

func newAliasedTable(tbl tableT, alias string) *sqlparser.AliasedTableExpr {
	return sqlparser.NewAliasedTableExpr(tbl.tableExpr, alias)
}

func newAliasedColumn(col column, alias string) *sqlparser.AliasedExpr {
	return sqlparser.NewAliasedExpr(col.name, alias)
}

func getRandomComparisonExprOperator() sqlparser.ComparisonExprOperator {
	// =, <, >, <=, >=, !=, <=>
	return randomEl([]sqlparser.ComparisonExprOperator{0, 1, 2, 3, 4, 5, 6})
}

func getRandomOrderDirection() sqlparser.OrderDirection {
	// asc, desc
	return randomEl([]sqlparser.OrderDirection{0, 1})
}

// getRandomExpr returns a random expression
func getRandomExpr(genConfig sqlparser.ExprGeneratorConfig, generators ...sqlparser.ExprGenerator) sqlparser.Expr {
	seed := time.Now().UnixNano()
	g := sqlparser.NewGenerator(seed, 2, generators...)
	return g.Expression(genConfig)
}

func randomEl[K any](in []K) K {
	return in[rand.Intn(len(in))]
}
